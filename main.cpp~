
/*
 * Chip-8 emulator implementation
 */

#include <iostream>
#include <stack>
#include <vector>
#include <array>
#include <string>


namespace CHIP8 {

  struct nibble {
    unsigned char type    : 4;
    unsigned char padding : 4;

    nibble() {
      type |= 0x0;
      padding |= 0x0;
    };
    
    void setbit(const nibble nib) {
      type |= nib; // type = type | nib;
    }

  };

  struct mem_address {
    unsigned char a, b;
  };
  

  inline mem_address little2big_endian(mem_address in_byte)
  {

  }

  

  unsigned short parse_instruction(unsigned short opcode)
  {
    switch(opcode & 0xF000) {
      // ignored
    case 0x0000: {
      // ignored

      if ((opcode & 0x0000) == 0x0000) {
	// ignored
      }
      else if ((opcode & 0x00E0) == 0x00E0) {
	screen.clear();
	program_counter += 2;
      }
      else if((opcode | 0x00EE) == 0x00EE) {
	program_counter = callstack.top();
	callstack.pop();
	program_counter += 2;
      }
    }
    
    case 0x1000: {
      program_counter = opcode & 0x0FFF;
      program_coutner += 2;
    }
    
    // call subroutine at NNN
    case 0x2000: {
      callstack.push(program_counter);
      program_counter = opcode & 0x0FFF;
    }

    // set Vx to NN
    case 0x6000: {
      reg[opcode & 0x0F00] = opcode & 0x00FF;
    }

    case 0x7000: {
      reg[opcode & 0x0F00] = opcode & 0x00FF;
    }

    case 0x8000: {
      switch (opcode | 0x000F) {
     
      case 0x0000:
	reg[opcode & 0x0F00] = reg[opcode & 0x00F0];
	break;
      case 0x0001:
	reg[opcode & 0x0F00] =| reg[opcode & 0x00F0];
	break;
      case 0x0002:
	reg[opcode & 0x0F00] =& reg[opcode & 0x00F0];
        break;
      case 0x0003:
	reg[opcode & 0x0F00] =^ reg[opcode & 0x00F0];
        break;
	// Adds VY to VX. VF is set to 1 when there's a carry, and to 0 when there isn't.
      case 0x0004:
	reg[opcode & 0x00F0] += reg[opcode & 0x0F00];
	if ((opcode & 0x0F00) + (opcode & 0x00F0) > 0xFF)
	  reg[0x000F] = 0x1;
	else
	  reg[0x000F] = 0x0;
	break;
	// VY is subtracted from VX. VF is set to 0 when there's a borrow, and 1 when there isn't.
	reg[opcode & 0x0F00] -= reg[opcode & 0x00F0];
	if ((opcode & 0x0F00) - (opcode & 0x00F0) < 0x0000)
	  reg[0xF] = 0x1;
      case 0x0005:
	if ((opcode & 0x0)
	break;
	case 0x0006:  // wrong
	    reg[0xF] = reg[opcode & 0x0F00] & (1 << 8)
	    reg[opcode & 0xF00] 
	break;
      case 0x0007:
	break;
      case 0x000E;
        break;
      default:
	break;

      }
    }
    else if ((opcode & 0xA000) == 0xA000) {
      I = opcode & 0x0FFF;
      program_counter += 2;
    }
  }


}


int main()
{
  std::array<unsigned char, 3584> main_memory;  // first 512 bytes reserved. Addressable range is 0x0200 - 0x0FFF
  std::array<unsigned char, 16> reg;  // 16 8 bit registers. Register 0xF doubles up as a carry flag
  std::stack<unsigned short> callstack(16);
  
  std::vector<unsigned short> opcode(35);  // opcodes are two byttes long with most significant byte stored first
  
  unsigned short program_counter;
  unsigned short I;

  std::vector<unsigned char> screen(64 * 32);


  return 0;
}
